#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass paper
\begin_preamble
\usepackage{graphics}
\usepackage{graphicx}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\bottommargin 2cm
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Advanced Systems Lab
\end_layout

\begin_layout SubTitle
Milestone 1 Report
\end_layout

\begin_layout Author
Karolos Antoniadis
\end_layout

\begin_layout Standard
This is the report of the first milestone of 
\begin_inset Quotes eld
\end_inset

Advanced System Lab
\begin_inset Quotes erd
\end_inset

 project.
 The report starts with an introduction of the system created for this milestone.
 Afterwards, in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:systemdesign"

\end_inset

 we describe the general design of the system, including the database, the
 middleware and the clients.
 In Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:testing"

\end_inset

 we describe how we tested the system.
 We follow with a description of the experimental setup and how the experiments
 were conducted in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:experimentalsetup"

\end_inset

.
 In Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:experiments"

\end_inset

 we continue by describing the experiments that were done and their evaluation.
 We conclude the report in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:conclusion"

\end_inset

.
\end_layout

\begin_layout Section
Introduction
\begin_inset CommandInset label
LatexCommand label
name "sec:introduction"

\end_inset


\end_layout

\begin_layout Standard
Goal of this milestone was to create a message passing system supporting
 persistent queues and a simple message format.
 Furthermore to experimentally evaluate it and determine its performance
 characteristics.
 The desired message passing system consists of three tiers.
 The first one implements the persistent queues using a database, which
 from now on will be referred as the 
\begin_inset Quotes eld
\end_inset

database tier
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

database
\begin_inset Quotes erd
\end_inset

 (db).
 The second tier implements the messaging system and is responsible of all
 the logic related to system management, also it is the one tier that is
 using the database in order to implement its functionality.
 We will refer to this tier as the 
\begin_inset Quotes eld
\end_inset

middleware tier
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

middleware
\begin_inset Quotes erd
\end_inset

 (mw).
 Finally, the third tier that implements the clients that send and receive
 messages using the middleware, this tier is going to be referred to as
 
\begin_inset Quotes eld
\end_inset

clients tier
\begin_inset Quotes erd
\end_inset

 or simply 
\begin_inset Quotes eld
\end_inset

clients
\begin_inset Quotes erd
\end_inset

.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "tiers"

\end_inset

 depicts the three tiers and they way they are connected to each other.
 As can been seen in the figure there is only one database while there can
 be more than one middlewares that are identical to each other and are connected
 to the database, as well as many clients connecting to different middlewares.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/tiers.png
	lyxscale 20
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The Three Tiers
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "tiers"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
System Design and Implementation
\begin_inset CommandInset label
LatexCommand label
name "sec:systemdesign"

\end_inset


\end_layout

\begin_layout Standard
In this section we describe the design of our system.
 We start by describing the code structure of our implementation and its
 main interface and afterwards we look more thoroughly at every tier and
 how its functionality was implemented.
\end_layout

\begin_layout Subsection*
Code Structure and Interfaces Overview
\end_layout

\begin_layout Standard
All the code for the client and the middleware was implemented in subpackages
 of 
\shape italic
ch.ethz.inf.asl
\shape default
.
 The package structure can be seen in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "packages"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
ch.ethz.inf.asl
\end_layout

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "99text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
client :: contains classes related to client code
\end_layout

\begin_layout Plain Layout
common :: package containing common classes to be used by both the clients
 and the middleware
\end_layout

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "99text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
request :: contains all the possible request classes and the 
\shape italic
Request
\shape default
 abstract class
\end_layout

\begin_layout Plain Layout
response :: contains all the possible response classes and the
\shape italic
 Response
\shape default
 abstract class
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
console :: contains the management console code
\end_layout

\begin_layout Plain Layout
exceptions :: contains relevant exceptions used by the application
\end_layout

\begin_layout Plain Layout
logger :: contains the 
\shape italic
Logger
\shape default
 class used for instrumenting the system
\end_layout

\begin_layout Plain Layout
main :: contains the Main class that is used to start the clients and the
 middleware
\end_layout

\begin_layout Plain Layout
middleware :: package containing classes related to the middleware
\end_layout

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "99text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
pool :: package containing pool implementations
\end_layout

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "99text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
connection :: contains the implementation of a connection pool
\end_layout

\begin_layout Plain Layout
thread :: contains the implementation of a thread pool
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
utils :: contains general utility methods for the application
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Package Structure
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "packages"

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
While designing the system we came to the realization that the communication
 protocol, meaning the messages that are being sent, for example send message,
 receive message etc.
 are the same between the clients and the middleware and between the middleware
 and the database.
 They are the same in the sense that when a client wants to send a message
 he has to issue some kind of send message request to the middleware.
 Similarly when the middleware wants to serve a send message request or
 the client he can issue a send message to the database.
 Because of this we created the interface that can be seen in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "protocol"

\end_inset

.
 This interface can be found in the 
\shape italic
MessagingProtocol
\shape default
 interface and is implemented by both 
\shape italic
ClientMessagingProtocolImpl
\shape default
 and 
\shape italic
MiddlewareMessagingProtocolImpl
\shape default
 classes.
 The difference between the two implementations is that in the client implementa
tion when for example 
\shape italic
sendMessage(...)
\shape default
 is called an underlying connection is used to a send a message from the
 client to the middleware that informs the middleware of the desire of the
 client to send a message.
 While on the other hand when the middleware calls 
\shape italic
sendMessage(...)
\shape default
 the middleware is calling a stored function from the database to actually
 
\begin_inset Quotes eld
\end_inset

save
\begin_inset Quotes erd
\end_inset

 the message in the database.
 More on how this interface was implemented by the client and the middleware
 is given in their corresponding subsections.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\shape italic
int sayHello(String clientName);
\end_layout

\begin_layout Plain Layout

\shape italic
void sayGoodbye();
\end_layout

\begin_layout Plain Layout

\shape italic
int createQueue(String queueName);
\end_layout

\begin_layout Plain Layout

\shape italic
void deleteQueue(int queueId);
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\shape italic
void sendMessage(int queueId, String content);
\end_layout

\begin_layout Plain Layout

\shape italic
void sendMessage(int receiverId, int queueId, String content);
\end_layout

\begin_layout Plain Layout

\shape italic
Optional<Message> receiveMessage(int queueId, boolean retrieveByArrivalTime);
\end_layout

\begin_layout Plain Layout

\shape italic
Optional<Message> receiveMessage(int senderId, int queueId, boolean retrieveByAr
rivalTime);
\end_layout

\begin_layout Plain Layout

\shape italic
Optional<Message> readMessage(int queueId, boolean retrieveByArrivalTime);
\end_layout

\begin_layout Plain Layout

\shape italic
int[] listQueues();
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Messaging Protocol Interface
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "protocol"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As can be seen from Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "protocol"

\end_inset

 the retrieving messages methods use the 
\shape italic
retrieveByArrivalTime
\shape default
 parameter.
 If this parameter is true then the message retrieved is the oldest one.
 The 
\shape italic
readMessage()
\shape default
 method is different to its corresponding 
\shape italic
receiveMessage()
\shape default
 method since it only reads a message from the system but is not actually
 removing it.
 
\end_layout

\begin_layout Subsection*
Database
\end_layout

\begin_layout Standard
The PostgreSQL database management system was used, specifically PostgreSQL
 (release 9.3.5).
 It was need for the system to persistent store information so a database
 was used to store the needed information for the clients, the queues and
 the messages.
 For this reason three tables were created as can been seen in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "tables"

\end_inset

 with their fields and their respective SQL types.
 As can been seen in this figure the fields 
\shape italic
sender_id
\shape default
,
\shape italic
 receiver_id 
\shape default
and
\shape italic
 queue_id 
\shape default
are all foreign keys of the
\shape italic
 message 
\shape default
table.
 The first two are associated with the
\shape italic
 id 
\shape default
of the 
\shape italic
client 
\shape default
table, while
\shape italic
 queue_id
\shape default
 is connected to the
\shape italic
 id 
\shape default
of the
\shape italic
 queue 
\shape default
table.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center

\shape italic
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape italic
client
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\shape italic
id
\series default
 serial primary key
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\shape italic
name 
\series default
varchar(20) NOT NULL
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hspace{0.5cm}
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape italic
queue
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\shape italic
id
\series default
 serial primary key
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\shape italic
name
\series default
 varchar(20) NOT NULL
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{0.5cm}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\shape italic
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="1">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape italic
message
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\shape italic
id
\series default
 serial primary key
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\shape italic
sender_id
\series default
 integer REFERENCES client(
\series bold
id
\series default
) NOT NULL
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\shape italic
receiver_id
\series default
 integer REFERENCES client(
\series bold
id
\series default
)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\shape italic
queue_id
\series default
 integer REFERENCES queue(
\series bold
id
\series default
) NOT NULL
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\shape italic
arrival_time
\series default
 timestamp NOT NULL
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\shape italic
message
\series default
 text NOT NULL
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Tables
\begin_inset CommandInset label
LatexCommand label
name "tables"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As can be seen all of the fields except the 
\shape italic
receiver_id
\shape default
 of the 
\shape italic
message
\shape default
 table cannot contain the 
\shape italic
NULL
\shape default
 value.
 This was a deliberate choice since it is possible for a message to be sent
 with no particular receiver in mind and such a message could possibly be
 received by any other client (except the client that sent the message).
 In such a case, i.e.
 a message has no specific receiver, the 
\shape italic
receiver_id 
\shape default
contains the 
\shape italic
NULL
\shape default
 value.
\end_layout

\begin_layout Standard
The 
\shape italic
message
\shape default
 table has also two check constraints associated with it.
 Those constraints are: 
\end_layout

\begin_layout Enumerate

\shape italic
CONSTRAINT check_length CHECK (LENGTH(message) <= 2000)
\end_layout

\begin_layout Enumerate

\shape italic
CONSTRAINT check_cannot_send_to_itself CHECK (sender_id != receiver_id)
\end_layout

\begin_layout Standard
The 
\shape italic
check_length
\shape default
 constraint checks that a message cannot contain a message with too much
 content, in this case one with more than 2000 characters, this constraint
 was removed during the 
\begin_inset Quotes eld
\end_inset

increasing message size
\begin_inset Quotes erd
\end_inset

 experiment.
 The second constraint was added because it was considered meaningless for
 a client to send a message to himself.
 It is also considered meaningless for a client to receive a message he
 sent (in case the 
\shape italic
receiver_id
\shape default
 is 
\shape italic
NULL
\shape default
), this is also checked in the stored function and is explained later on.
\end_layout

\begin_layout Standard
In order to increase the performance of the database, indexes were used.
 PostgreSQL creates by default indexes on the primary keys
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

Adding a primary key will automatically create a unique btree index on the
 column or group of columns used in the primary key.
\begin_inset Quotes erd
\end_inset

 (http://www.postgresql.org/docs/9.3/static/ddl-constraints.html)
\end_layout

\end_inset

.
 The extra indexes that were introduced are the following: 
\end_layout

\begin_layout Enumerate

\shape italic
CREATE INDEX ON message (receiver_id, queue_id)
\end_layout

\begin_layout Enumerate

\shape italic
CREATE INDEX ON message (sender_id)
\end_layout

\begin_layout Enumerate

\shape italic
CREATE INDEX ON message (arrival_time)
\end_layout

\begin_layout Standard
The first index was introduced to make faster the retrieval of message since
 most of them are based on a 
\shape italic
receiver_id 
\shape default
and on a 
\shape italic
queue_id
\shape default
.
 Note that the field 
\shape italic
receiver_id
\shape default
 appears first on this multicolumn index, this was not a random choice since
 it is known
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

...but the index is most efficient when there are constraints on the leading
 (leftmost) columns.
\begin_inset Quotes erd
\end_inset

 (http://www.postgresql.org/docs/9.3/static/indexes-multicolumn.html)
\end_layout

\end_inset

 that the in a multicolumn index the leftmost column can also be efficiently
 used solo.
 The case where 
\shape italic
receiver_id
\shape default
 is used alone and not in combination with 
\shape italic
queue_id
\shape default
 is the listing queues query that lists the queues where a message for a
 client exists.
 The second index was created to speed up receiving of messages from a specific
 sender.
 The third index was introduced since some of the receiving messages functions
 receive messages based on the arrival time.
 
\end_layout

\begin_layout Standard
Code for the creation of the tables and the indexes can be found in the
 
\family typewriter
auxiliary_functions.sql
\family default
 file in 
\family typewriter
src/main/resources
\family default
.
\end_layout

\begin_layout Subsubsection*
Stored Functions
\end_layout

\begin_layout Standard
Stored functions were created using the PL/pgSQL procedural language to
 reduce the network communication time between the middleware and the database.
 Also stored functions have the advantage that they are compiled already
 by the DBMS and their query plan has been generated so they can be reused
 and therefore increa
\emph on
se
\emph default
 performance.
 The code for the stored functions can be found in 
\family typewriter
read_committed_basic_functions.sql
\family default
 file in 
\family typewriter
src/main/resources
\family default
 and all of them are used to be able to implement the interface shown in
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "protocol"

\end_inset

.
\end_layout

\begin_layout Standard
The stored functions 
\shape italic
read_message
\shape default
 and 
\shape italic
receive_message
\shape default
 specifically check that if a message has no receiver it is not being returned
 to the client that sent it since this cannot be catched by the 
\shape italic
check_cannot_send_to_itself
\shape default
 constraint because in those cases the 
\shape italic
receiver_id
\shape default
 is 
\shape italic
NULL
\shape default
.
\end_layout

\begin_layout Standard
Stored functions were not used everywhere, only where it made sense.
 For example in cases where the same SQL queries did not need to be executed
 many times, simple queries were sent to the database instead, e.g.
 management console.
\end_layout

\begin_layout Subsubsection*
Transactions and Isolation Levels
\end_layout

\begin_layout Standard
In this subsection we discuss isolation levels and why they are important
 for the correctness of our system.
 In order to do so let us see a simplified version of the internals of the
 
\shape italic
receive_message
\shape default
 stored function, seen in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "receiveMessage"

\end_inset

, that takes two parameters, the 
\shape italic
p_requesting_user_id
\shape default
 and the 
\shape italic
p_queue_id
\shape default
 and is trying to find a message for the requesting user in the given queue.
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center

\shape italic
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Plain Layout

\shape italic
SELECT id INTO received_message_id FROM message WHERE queue_id = p_queue_id
 AND receiver_id = p_requesting_user_id LIMIT 1;
\end_layout

\begin_layout Plain Layout

\shape italic
RETURN QUERY SELECT * FROM message WHERE id = received_message_id;
\end_layout

\begin_layout Plain Layout

\shape italic
DELETE FROM message where id = received_message_id; 
\end_layout

\end_inset


\shape default

\begin_inset Caption Standard

\begin_layout Plain Layout
Simplified Version of 
\shape italic
receive_message
\shape default
 Body 
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "receiveMessage"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Functions in PostgreSQL are executed within transactions
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

Functions and trigger procedures are always executed within a transaction
 established by an outer query
\begin_inset Quotes erd
\end_inset

 (http://www.postgresql.org/docs/current/interactive/plpgsql-structure.html)
\end_layout

\end_inset

.
 Transactions are known to be atomic, in the sense that they either 
\begin_inset Quotes eld
\end_inset

happen
\begin_inset Quotes erd
\end_inset

 completely, i.e.
 all their effects take place, or not at all.
 But still problems could arise! The default isolation level in PostgreSQL
 is READ COMMITTED
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.postgresql.org/docs/9.3/static/transaction-iso.html
\begin_inset CommandInset label
LatexCommand label
name "fn:transactionsLink"

\end_inset


\end_layout

\end_inset

 which roughly states 
\begin_inset Quotes eld
\end_inset

...a SELECT query (without a FOR UPDATE/SHARE clause) sees only data committed
 before the query began; it never sees either uncommitted data or changes
 committed during query execution by concurrent transactions.
\begin_inset Quotes erd
\end_inset


\begin_inset script superscript

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand ref
reference "fn:transactionsLink"

\end_inset


\end_layout

\end_inset

.
 So with such an isolation level it is possible for two concurrent transactions
 to read the exact same message, only one of them will delete it, but both
 of them will return it.
 This of course is not acceptable since we want a message to be read by
 only one client.
 In order to solve this problem there are at least two approaches:
\end_layout

\begin_layout Enumerate
Use 
\shape italic
FOR UPDATE
\shape default

\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

FOR UPDATE causes the rows retrieved by the SELECT statement to be locked
 as though for update.
 This prevents them from being modified or deleted by other transactions
 until the current transaction ends.
\begin_inset Quotes eld
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

That is, other transactions that attempt UPDATE, DELETE, SELECT FOR UPDATE,
 SELECT FOR NO KEY UPDATE, SELECT FOR SHARE or SELECT FOR KEY SHARE of these
 rows will be blocked until the current transaction ends.
 
\begin_inset Quotes eld
\end_inset

 (http://www.postgresql.org/docs/9.3/static/sql-select.html#SQL-FOR-UPDATE-SHARE)
\begin_inset CommandInset label
LatexCommand label
name "fn:FOR-UPDATE-causes"

\end_inset


\end_layout

\end_inset

and therefore prevent other transactions from selecting the same message.
\end_layout

\begin_layout Enumerate
Change isolation level to 
\shape italic
REPEATABLE READ
\shape default
 which is stronger than 
\shape italic
READ COMMITTED
\shape default
 and roughly states  
\begin_inset Quotes eld
\end_inset

This level is different from Read Committed in that a query in a repeatable
 read transaction sees a snapshot as of the start of the transaction, not
 as of the start of the current query within the transaction.
\begin_inset Quotes erd
\end_inset


\begin_inset script superscript

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand ref
reference "fn:transactionsLink"

\end_inset


\end_layout

\end_inset

.
 In case another transaction deletes the message in the meantime the transaction
s is going to fail by giving back an error.
 
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

problem
\begin_inset Quotes erd
\end_inset

 with the second approach is that a transaction could find concurrent update
 errors and will have to be re-executed: 
\begin_inset Quotes eld
\end_inset

...it should abort the current transaction and retry the whole transaction
 from the beginning.
\begin_inset Quotes erd
\end_inset


\begin_inset script superscript

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand ref
reference "fn:transactionsLink"

\end_inset


\end_layout

\end_inset

.
 For the above reasons we used the first approach since it made our application
 code easier, i.e.
 not having to repeat a transaction.
\end_layout

\begin_layout Standard
We have to mention here that the 
\shape italic
SELECT
\shape default
 command combined with 
\shape italic
FOR UPDATE
\shape default
 and 
\shape italic
ORDER BY
\shape default
 could have some problems: 
\begin_inset Quotes eld
\end_inset

It is possible for a SELECT command running at the READ COMMITTED transaction
 isolation level and using 
\shape italic
ORDER BY
\shape default
 and a locking clause to return rows out of order.
\begin_inset Quotes erd
\end_inset


\begin_inset script superscript

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand ref
reference "fn:FOR-UPDATE-causes"

\end_inset


\end_layout

\end_inset

.
 This is because ordering of the rows occurs before locking them, so it
 is possible that when the rows are locked some columns might have been
 modified.
 This is not a problem in our implementation since we delete the selected
 row.
\end_layout

\begin_layout Subsubsection*
Connecting Java and PostgreSQL
\end_layout

\begin_layout Standard
For the connection between Java and the database the JDBC41 PostgreSQL driver
\begin_inset Foot
status open

\begin_layout Plain Layout
http://jdbc.postgresql.org/download.html
\end_layout

\end_inset

 was used.
\end_layout

\begin_layout Subsubsection*
What is being logged?
\end_layout

\begin_layout Standard
The only thing that is being logged in the database while it is being used
 is he the CPU, network and memory utilization using the dstat
\begin_inset Foot
status open

\begin_layout Plain Layout
http://dag.wiee.rs/home-made/dstat/
\end_layout

\end_inset

 tool.
\end_layout

\begin_layout Subsubsection*
Management Console
\end_layout

\begin_layout Standard
A management console was also created (it is implemented in the 
\shape italic
Manager
\shape default
 class under the 
\shape italic
console
\shape default
 package) to easily check the contents of a database in a remote machine.
 The console is a GUI application and can be seen Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "management"

\end_inset

.
 The user of the console just has to provide the host address and port number
 of where the database is running, as well as the username, password and
 database name.
 Then by clicking 
\begin_inset Quotes eld
\end_inset

Login
\begin_inset Quotes erd
\end_inset

 and the appropriate 
\begin_inset Quotes eld
\end_inset

Refresh
\begin_inset Quotes erd
\end_inset

 buttons he can check the current data of the client, queue or message table.
 For retrieving the data from the database simple 
\begin_inset Quotes erd
\end_inset


\shape italic
SELECT * FROM ...
\shape default

\begin_inset Quotes eld
\end_inset

 queries were issued on the database, no stored functions were created for
 this since they are only used for the console and quite sparingly.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/management.png
	lyxscale 20
	scale 40

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Management Console Screenshot
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "management"

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In order to use the management console the 
\shape italic
main()
\shape default
 method from the
\shape italic
 Manager
\shape default
 class needs to be executed.
\end_layout

\begin_layout Subsection*
Middleware
\end_layout

\begin_layout Standard
The middleware implements the messaging system, it receives requests/messages
 from clients and has to use the database in order to persist those messages,
 as well as retrieve the messages from the database to return to the clients.
 Obviously if we want to be able to support more than one client the middleware
 needs to be multi-threaded.
 The interface that the middleware has to implement can be seen in Figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "protocol"

\end_inset

.
\end_layout

\begin_layout Standard
Our middleware follows a non-blocking approach using simple Java IO.
 This seems hard to believe at first but nevertheless this is the case as
 will be explained later on.
 But before doing so, let us see some of the possible approaches that can
 be used to implement a middleware.
\end_layout

\begin_layout Itemize
In this approach the middleware would have some threads, also known as worker
 threads, on the middleware and every one of them waits for a connection
 from the client.
 When a connection is established the thread blocks and waits for a request
 from the client.
 When it receives the request it, it executes the request meaning it issues
 the corresponding operations to the database and then returns the response
 back to the client.
 Afterwards it closes the connection and waits for the next client connection.
 Although this approach can support an arbitrary number of client it is
 quite wasteful and slow since for every request-response interaction the
 client has to establish a connection with the middleware.
 
\end_layout

\begin_layout Itemize
With this approach we have a worker thread for every client.
 A worker thread is created when a client connects and then it is used for
 this client until the end.
 The advantage of this approach in contrast to the previous is that there
 does not have to be an establishment of a connection for every request
 between the client and the middleware.
 But this solution seems to have scalability issues since the number of
 clients the middleware could possibly support is bounded by the number
 of threads the system can support.
 
\end_layout

\begin_layout Itemize
This approach uses Java New IO.
 The rough idea is having a thread, called selector thread, that blocks
 until a new connection from a client is established or data from some already
 established connection are received.
 When data from a connection are received the reading of the data can be
 passed to a worker thread that is going to do the actual reading and the
 one that is going to send the response back to the client.
 This solution has none of the above problems.
\end_layout

\begin_layout Standard
Our approach followed a different way.
 Its main idea is to have a queue of sockets corresponding to connections
 from the clients.
 Every time a client connects to the middleware the socket is being added
 to this queue.
 Then there are also some worker threads operating in a round-robin approach
 on this queue and check if there is something to read from the underlying
 input stream of the socket.
 If yes they read the data, use the database to perform their operation
 and send the response back to the client.
 This approach has none of the problems described in the first two approaches.
 Our implementation of this approach is non-blocking since a worker thread
 never blocks to wait for data from a specific connection, if there are
 no data in a connection it just puts the connection back to the queue and
 continues with the next connection.
 The non-blocking implementation was achieved by using 
\shape italic
InputStream
\shape default
's 
\shape italic
available()
\shape default
 method that can return the number of bytes that can be read without blocking.
 
\shape italic
available()
\shape default
 is of course a non-blocking method which means a worker thread issues a
 blocking 
\shape italic
read()
\shape default
 method call only when 
\shape italic
available()
\shape default
 showed that a number of bytes can be read without blocking.
 In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "middlewareArchitecture"

\end_inset

 the architecture of our middleware is depicted while in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "workerThread"

\end_inset

 it is shown how a middleware's worker thread operates.
 As can be seen in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "middlewareArchitecture"

\end_inset

 the worker threads of the middleware interact with the sockets queue, as
 well as with the connection pool in order to get a connection to the database
 for issuing their request.
 Note furthermore that the 
\begin_inset Quotes eld
\end_inset

waiting for a connection
\begin_inset Quotes erd
\end_inset

 part of the middleware is blocking.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/middlewareArchitecture.png
	lyxscale 20
	scale 21

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Middleware Architecture
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "middlewareArchitecture"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/workerThread.png
	lyxscale 10
	scale 22

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Worker Thread of the Middleware
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "workerThread"

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Middleware Implementation
\end_layout

\begin_layout Standard
The implementation of the middleware is located under the package with the
 same name: 
\shape italic
ch.ethz.inf.asl.middleware
\shape default
.
 This package contains the following classes:
\end_layout

\begin_layout Itemize

\shape italic
Middleware
\shape default
: this is the class that needs to be instantiated to start the middleware.
 It is constructed using a configuration, what is needed for the configuration
 is explained later on.
 By calling its 
\shape italic
start()
\shape default
 method the middleware initializes the thread pool and waits for upcoming
 connections from clients.
 When a client connects his corresponding connection is inserted into the
 sockets queue.
\end_layout

\begin_layout Itemize

\shape italic
MiddlewareRunnable
\shape default
: this class corresponds to a worker thread.
 It is being constructed with the middleware's sockets queue as well as
 the connection pool created from the middleware.
\end_layout

\begin_layout Itemize

\series bold
\shape italic
InternalSocket
\series default
\shape default
: the middleware socket queue does not actually contain immediate
\shape italic
 Socket (javat.net.Socket)
\shape default
 objects but actually 
\shape italic
InternalSocket
\shape default
 objects.
 An internal socket contains internally a normal Java socket as well as
 some extra methods.
 For instance it has a method that returns the last time this socket was
 worked on (
\shape italic
getLastTime()
\shape default
), this method is helpful for logging purposes, i.e.
 we can now know how much a socket was waiting on the sockets queue before
 it was picked by a worker thread.
 This class also supports reading data in chunks! Because we use the 
\shape italic
available()
\shape default
 method as was said previously it is possible to have only 1 byte available
 per time and in such cases we need somehow to accumulate the read bytes
 until we have read the full request.
 
\shape italic
InternalSocket
\shape default
 achieves this operation by calling 
\shape italic
addData(byte[] readData)
\shape default
 every time we read some bytes and we can get the accumulated bytes until
 now by calling 
\shape italic
getObjectData()
\shape default
.
\end_layout

\begin_layout Itemize

\shape italic
MiddlewareMessagingProtocolImpl
\shape default
: this class implements the 
\shape italic
MessagingProtocol
\shape default
 interface and is the one that actually calls the stored functions.
\end_layout

\begin_layout Subsubsection*
Thread & Connection Pool
\end_layout

\begin_layout Standard
Our own thread and connection pools were implemented, their code can be
 found under the 
\shape italic
ch.ethz.inf.asl.middleware.pool.thread
\shape default
 and 
\shape italic
ch.ethz.inf.asl.middleware.pool.connection
\shape default
 packages in the 
\shape italic
ThreadPool
\shape default
 and 
\shape italic
ConnectionPool
\shape default
 classes respectively.
 Let us see each of these classes:
\end_layout

\begin_layout Itemize

\shape italic
ThreadPool
\shape default
: this class is instantiated given the number of threads the desired pool
 needs to have.
 This class creates the given amount of threads and executes them, every
 one of those threads waits to receive another thread submitted by the user
 of the thread pool to execute it.
 In order to execute a thread we just have to call the pool's 
\shape italic
execute(Runnable command)
\shape default
 method that just adds the 
\shape italic
command
\shape default
 in the queue to be executed.
 The 
\shape italic
execute()
\shape default
 method might block if the underlying queue is full.
 The queue of the threads that is used internally by this classes to 
\begin_inset Quotes eld
\end_inset

save
\begin_inset Quotes erd
\end_inset

 the commands is a Java's 
\shape italic
ArrayBlockingQueue
\shape default
 queue, that is, a thread-safe bounded queue implementation that orders
 elements 
\series bold
FIFO
\series default
 (first-in-first-out).
\end_layout

\begin_layout Itemize

\shape italic
ConnectionPool
\shape default
: this class can be constructed given the maximum amount of connections
 we need and the login credentials of the database.
 Afterwards a call to 
\shape italic
getConnection()
\shape default
 returns a 
\shape italic
Connection
\shape default
 object.
 Until the maximum number of connections is reached, new connections are
 being created on every call to 
\shape italic
getConnection()
\shape default
, afterwards they are being re-used.
 The 
\shape italic
getConnection()
\shape default
 method blocks when there are no more available connections at the moment.
 When the 
\shape italic
close()
\shape default
 method is called on a 
\shape italic
Connection
\shape default
 object returned by 
\shape italic
getConnection()
\shape default
 the closed connection is not actually closed but just returned back to
 the pool to be re-used.
 This was achieved by creating the 
\shape italic
InternalConnection
\shape default
 inner class that contains a Java's 
\shape italic
Connection
\shape default
 object internally and also extends the 
\shape italic
Connection
\shape default
 class.
 Whenever a call to an 
\shape italic
InternalConnection
\shape default
 method is issued the corresponding 
\shape italic
Connection
\shape default
 object method is called.
 Except in the case when the 
\shape italic
close()
\shape default
 method is called in which case the specific connection is returned back
 to the pool.
 The connection pool can also be closed by calling its respective 
\shape italic
close() 
\shape default
method which is going to close all the connections currently existing in
 the pool, or it can be used in a try-with-resources statement since it
 implements the 
\shape italic
AutoCloseable
\shape default
 interface.
 Internally the connection pool uses 
\shape italic
ArrayBlockingQueue
\shape default
 similarly to the thread pool implementation.
 This means that requests to 
\shape italic
getConnection()
\shape default
 that are waiting are waiting in a FIFO way.
\end_layout

\begin_layout Subsubsection*
Serialization of Messages
\end_layout

\begin_layout Standard
A question that might arise by reading this report until now might be how
 are requests and responses formatted before being transmitted between the
 clients and the middleware.
 Answer: they are serialized.
 All the requests and all the responses implement the 
\shape italic
Serializable
\shape default
 interface, so they can easily be serialized to a 
\shape italic
byte
\shape default
 array.
 This array's length is calculated and the resulted length is transformed
 to exactly 4 bytes (1 
\shape italic
int
\shape default
).
 The length is concatenated with the serialized byte array, with the length
 being in the front.
 This concatenated array is what is being transmitted between the client
 and the middleware.
 The length is added so when the middleware starts reading data from the
 client it can read the length of the upcoming object (look 
\shape italic
InternalSocket
\shape default
) and know when to stop reading.
 When it reads the whole data, it removes the length part and deserializes
 the remaining byte array to get the 
\shape italic
Request
\shape default
 object.
 The middleware creates the response in the exact same way before sending
 it to the client.
 Although this is not necessary for the client, since the client blocks
 until he reads the response.
 But it was done nevertheless for consistency reasons so the clients and
 the middlewares send and receive in the same way.
\end_layout

\begin_layout Subsubsection*
Where do requests get queued up?
\end_layout

\begin_layout Standard
From the above description of the system it is easy to see that there are
 two main parts of the system were a request could stuck waiting.
 The one is in the sockets queue waiting until its socket is being worked
 on by a worker thread.
 The second part is waiting for the connection, after getting the request
 the middleware might have to wait for others worker threads to finish their
 database requests until it is able to proceed with its own.
 Until then it waits in the connection queue of the connection pool.
\end_layout

\begin_layout Subsubsection*
What is being logged?
\end_layout

\begin_layout Standard
Every worker thread in the middleware logs its own data.
 This was done so they worker threads do not contend with each other while
 logging.
 Afterwards the logs can be merged and be sorted by time to be analyzed.
\end_layout

\begin_layout Standard
A snippet of some middleware logs can been seen in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "middlewareLog"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
16045 5 WAITING THREAD 
\end_layout

\begin_layout Plain Layout
16167 25 # OF ENTERS 
\end_layout

\begin_layout Plain Layout
16167 1 # TO READ 
\end_layout

\begin_layout Plain Layout
16340 110 GOT CONNECTION 
\end_layout

\begin_layout Plain Layout
16365 25 DB REQUEST SEND_MESSAGE 
\end_layout

\begin_layout Plain Layout
16366 321 READING INSIDE 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Middleware Log Snippet
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "middlewareLog"

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

In the snippet of Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "middlewareLog"

\end_inset

 the left column corresponds to the time in milliseconds (ms) since when
 this worker thread starting working.
 So, we can infer that this snippet was taken from the 16th second of the
 log.
 All the time values in the snippet are counted in milliseconds.
 We can see 6 types of logs in the snippet, those are all the possible types
 that are logged.
 Let us see each one of them:
\end_layout

\begin_layout Enumerate
\begin_inset Quotes eld
\end_inset

WAITING THREAD
\begin_inset Quotes erd
\end_inset

: corresponds to the time the connection was waiting until it got picked
 up by a worker thread, in the snippet this was 5ms.
\end_layout

\begin_layout Enumerate
\begin_inset Quotes eld
\end_inset

# OF ENTERS
\begin_inset Quotes erd
\end_inset

: corresponds to the times this socket has been picked by a worker thread
 but at the time did not contain any data.
 In this case the specific socket has been picked up by a worker thread
 25 times and all of them except the last one the socket did not contain
 any data for reading.
\end_layout

\begin_layout Enumerate
\begin_inset Quotes eld
\end_inset

# TO READ
\begin_inset Quotes erd
\end_inset

: is the times the socket had been picked by a worker thread (after it started
 having data) in order for it to read its whole request.
 As it was said it is possible to have very few bytes available every time
 a socket contains data, which means those bytes are read and then the socket
 is returned back to its queue.
 This number merely shows how many times the socket entered the queue from
 the moment it had data for reading until all its data (one request) were
 read.
 In the above snippet the number is 1 which means the moment the whole request
 was read at once (all the data were there) by the worker thread.
\end_layout

\begin_layout Enumerate
\begin_inset Quotes eld
\end_inset

GOT CONNECTION
\begin_inset Quotes erd
\end_inset

: corresponds to the time it took a thread to get a connection from the
 connection pool.
 In the snippet case this is 110ms.
\end_layout

\begin_layout Enumerate
\begin_inset Quotes eld
\end_inset

DB_REQUEST
\begin_inset Quotes erd
\end_inset

: corresponds to the time it took for a database request.
 In the snippet's case it took 25ms for a 
\begin_inset Quotes eld
\end_inset

SEND_MESSAGE
\begin_inset Quotes erd
\end_inset

 request.
 Request could also be 
\begin_inset Quotes eld
\end_inset

RECEIVE_MESSAGE
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

LIST_QUEUES
\begin_inset Quotes erd
\end_inset

.
 The value of this log actually also contains the time for request to be
 sent to the database, executed in the database and then sent back to the
 middleware.
 
\end_layout

\begin_layout Enumerate
\begin_inset Quotes eld
\end_inset

READING INSIDE
\begin_inset Quotes erd
\end_inset

: corresponds to the time it took the thread to finish its job from the
 beginning when it picked a socket that had data till the end.
 In the snippet's case this is 321ms.
 
\end_layout

\begin_layout Standard
Obviously it should be the case that the time of time(
\begin_inset Quotes eld
\end_inset

READING INSIDE
\begin_inset Quotes erd
\end_inset

) >= time(
\begin_inset Quotes eld
\end_inset

GOT CONNECTION
\begin_inset Quotes erd
\end_inset

) + time(
\begin_inset Quotes eld
\end_inset

DB REQUEST
\begin_inset Quotes erd
\end_inset

).
 
\end_layout

\begin_layout Standard
Similarly to the database the CPU, memory and network utilization are logged.
 
\end_layout

\begin_layout Subsubsection*
Starting the Middleware
\end_layout

\begin_layout Standard
A middleware can be started by executing the 
\shape italic
main() 
\shape default
method of the 
\shape italic
Main
\shape default
 class giving two program arguments, the string 
\begin_inset Quotes eld
\end_inset

middleware
\begin_inset Quotes erd
\end_inset

 and the file path containing the configuration of the middleware.
 For example assuming we have an executable JAR file named 
\begin_inset Quotes eld
\end_inset

mepas.jar
\begin_inset Quotes erd
\end_inset

, then we can start the middleware by doing 
\begin_inset Quotes eld
\end_inset

java -jar mepas.jar middleware middleware.properties
\begin_inset Quotes erd
\end_inset

 where the properties file is similar to the one shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "mwPropertiesFile"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
databaseHost=172.31.12.119
\end_layout

\begin_layout Plain Layout
databasePortNumber=5432
\end_layout

\begin_layout Plain Layout
databaseName=mepas 
\end_layout

\begin_layout Plain Layout
databaseUsername=ubuntu 
\end_layout

\begin_layout Plain Layout
databasePassword=mepas$1$2$3$ 
\end_layout

\begin_layout Plain Layout
threadPoolSize=10 
\end_layout

\begin_layout Plain Layout
connectionPoolSize=20 
\end_layout

\begin_layout Plain Layout
middlewarePortNumber=6789
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Middleware Properties File
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "mwPropertiesFile"

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Most of the properties in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "mwPropertiesFile"

\end_inset

 are self explanatory, obviously the middleware needs the database credentials
 in order to start as well as the thread pool and connection pool sizes.
 The 
\begin_inset Quotes eld
\end_inset

middlewarePortNumber
\begin_inset Quotes erd
\end_inset

 corresponds to the port where the middleware is going to accept connections
 from.
\end_layout

\begin_layout Subsubsection*
Stopping the Middleware
\end_layout

\begin_layout Standard
The 
\shape italic
Middleware
\shape default
 creates a thread when started based on the 
\shape italic
MiddlewareStopper
\shape default
 inner class that is always running on the background.
 This thread blocks and waits in the standard input for a 
\begin_inset Quotes eld
\end_inset

STOP
\begin_inset Quotes erd
\end_inset

 string.
 When this string is entered the middleware is gracefully stopped by stopping
 the worker threads and by closing the connection pool and middleware's
 
\shape italic
ServerSocket
\shape default
.
 This way of stopping the middleware is useful for the experimental setup
 as will be explained in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:experimentalsetup"

\end_inset

.
\end_layout

\begin_layout Subsection*
Clients
\end_layout

\begin_layout Standard
The implementation of the clients can be found in the 
\shape italic
ch.ethz.inf.asl.client
\shape default
 package.
 It contains the following three classes:
\end_layout

\begin_layout Itemize

\shape italic
Client
\shape default
: is the class that needs to be instantiated to start the clients.
 Every client corresponds to a thread that is being executed, a 
\shape italic
ClientRunnable
\shape default
 thread.
\end_layout

\begin_layout Itemize

\shape italic
ClientRunnable
\shape default
: corresponds to a client.
 The way a client communicates with the middleware is implemented in this
 class.
\end_layout

\begin_layout Itemize

\shape italic
ClientMessagingProtocolImpl
\shape default
: this class implements the 
\shape italic
MessagingProtocol
\shape default
 interface.
 It is responsible for serializing the requests before sent, deserializing
 the responses when they are received and actually sending and receiving
 the requests and the responses to the middleware.
\end_layout

\begin_layout Subsubsection*
Workload
\end_layout

\begin_layout Standard
While thinking of the workload of the clients we wanted to have a stable
 workload and one that does not arbitrarily increases the size of the 
\shape italic
message
\shape default
 table in the database.
 So we came up with the following workload, where every client executes
 what is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "workload"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/clientWorkload.png
	lyxscale 10
	scale 22

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Client's Workload
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "workload"

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

The clients have no thinking time, they just send requests to the middleware
 as fast as possible.
 Also in every iteration of a loop a client sends one message, list the
 queues once and might call receive message multiple times for different
\begin_inset Foot
status open

\begin_layout Plain Layout
This is because of the way the 
\shape italic
list_queues
\shape default
 stored function is implemented.
 It returns distinct queue ids.
\end_layout

\end_inset

 queues.
 This way we noticed that the number of messages in the database was always
 in the around a hundred.
 This workload also has the benefit of using three different types of requests.
 Also notice that our clients do not use the 
\shape italic
sayHello()
\shape default
, 
\shape italic
createQueue()
\shape default
 or 
\shape italic
deleteQueue()
\shape default
 methods.
 This was done to simplify our experiments.
 Since the 
\shape italic
message
\shape default
 table has foreign keys to the 
\shape italic
client
\shape default
 and 
\shape italic
queue
\shape default
 tables it was possible when a client was trying to send a message to another
 that the other client has not yet been created.
 In such a case an error is logged and a failed response message is returned
 to the client.
 For this reason we chose to avoid that types of requests.
\end_layout

\begin_layout Standard
Initially clients were not sending random strings as content to each other
 but instead where sending a counter that was increased after every send.
 This was helpful for verifying that the system was operating correctly.
 This counter was replaced with random string during the 
\begin_inset Quotes eld
\end_inset

increasing the message size
\begin_inset Quotes erd
\end_inset

 experiment which is presented later in this report.
\end_layout

\begin_layout Subsubsection*
What is being logged?
\end_layout

\begin_layout Standard
As with the database and the middleware, clients also log the CPU, network
 and memory utilization using dstat.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
27581 28 SEND_MESSAGE (88, 37, HW8Z2) 
\end_layout

\begin_layout Plain Layout
27604 23 LIST_QUEUES 
\end_layout

\begin_layout Plain Layout
27629 25 RECEIVE_MESSAGE (49, 40, 1FJFY) 
\end_layout

\begin_layout Plain Layout
27653 24 RECEIVE_MESSAGE (68, 78, ITCI6) 
\end_layout

\begin_layout Plain Layout
27679 26 RECEIVE_MESSAGE (71, 85, 9XL3S)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Client Log Snippet
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "clientLog"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Every client thread logs for itself and at the end the logs are combined.
 This was done so there is no contention between the clients while logging.
 In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "clientLog"

\end_inset

 we can see a snippet on what a client logs.
 As can be seen on the left column the time since the logging started is
 logged similarly to the middleware logs.
 The second column contains the time in milliseconds it took for the given
 request to be served.
 This time includes the time for the request to be sent in the middleware,
 served by the middleware and sent back to the client.
 For example it took 23ms for the listing of the queues in the above log.
 The parentheses next to 
\begin_inset Quotes eld
\end_inset

SEND_MESSAGE
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

RECEIVE_MESSAGE
\begin_inset Quotes erd
\end_inset

 correspond to (queueId, senderId, first five characters of the content)
 and (queueId, receiverId, first five characters of the content) respectively.
 Only the first five characters of the content are used to reduce the generated
 logs size.
\end_layout

\begin_layout Subsubsection*
Starting the Clients
\end_layout

\begin_layout Standard
Similarly to the middleware the clients can be started by executing the
 
\shape italic
main()
\shape default
 method of the 
\shape italic
Main
\shape default
 class.
 Two arguments need to provided, the first one should always be 
\begin_inset Quotes eld
\end_inset

client
\begin_inset Quotes erd
\end_inset

 while the second one corresponds to the file path of the configuration
 of the clients.
 Such a configuration can been seen in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "clientProperties"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
middlewareHost=172.31.8.29 
\end_layout

\begin_layout Plain Layout
middlewarePortNumber=6789 
\end_layout

\begin_layout Plain Layout
numberOfClients=50 
\end_layout

\begin_layout Plain Layout
totalClients=50 
\end_layout

\begin_layout Plain Layout
totalQueues=50 
\end_layout

\begin_layout Plain Layout
startingId=1
\end_layout

\begin_layout Plain Layout
messageSize=20
\end_layout

\begin_layout Plain Layout
runningTimeInSeconds=600
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Client Properties File
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "clientProperties"

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Obviously the client needs to be aware of where the middleware resides,
 therefore 
\begin_inset Quotes eld
\end_inset

middlewareHost
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

middlewarePortNumber
\begin_inset Quotes erd
\end_inset

 exist in the client configuration.
 The 
\begin_inset Quotes eld
\end_inset

numberOfClients
\begin_inset Quotes erd
\end_inset

 corresponds to the 
\begin_inset Quotes eld
\end_inset

numberOfClients
\begin_inset Quotes erd
\end_inset

 (number of threads) that are going to be executed by these
\shape italic
 Client
\shape default
 execution while 
\begin_inset Quotes eld
\end_inset

totalClients
\begin_inset Quotes erd
\end_inset

 are the total clients currently in the system, i.e.
 where a client can send a message.
 Since many 
\shape italic
Client
\shape default
's executions could possibly be running from different machines the 
\begin_inset Quotes eld
\end_inset

startingId
\begin_inset Quotes erd
\end_inset

 is used so a specific 
\shape italic
Client
\shape default
 execution knows how to assign ids to its clients.
 The 
\begin_inset Quotes eld
\end_inset

messageSize
\begin_inset Quotes erd
\end_inset

 corresponds to the length of the content of a message that is being sent
 in characters.
 After 
\begin_inset Quotes eld
\end_inset

runningTimeInSeconds
\begin_inset Quotes erd
\end_inset

 the clients stop working and leave the system.
\end_layout

\begin_layout Standard
Also note that when starting the clients all the clients are connected to
 one specific middleware.
 It is not possible to have clients from a 
\shape italic
Client
\shape default
 execution that are connected to different middlewares.
\end_layout

\begin_layout Subsection*
General Remarks 
\end_layout

\begin_layout Subsubsection*
One Request and One Response Class Per Request Type
\end_layout

\begin_layout Standard
For every type of request the client can send to the middleware there exists
 a respective class for this request.
 And for every specific request there is a corresponding response class.
 The related to requests and responses classes can be found under the 
\shape italic
ch.ethz.inf.asl.common.request
\shape default
 and 
\shape italic
ch.ethz.inf.asl.common.response
\shape default
 packages.
 In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "requestAndResponse"

\end_inset

 we can see the 
\shape italic
Request
\shape default
 and 
\shape italic
Response
\shape default
 abstract classes with some of their basic methods.
 Note that the 
\shape italic
Request
\shape default
 class uses a generic type 
\shape italic
R
\shape default
, that is a subclass of 
\shape italic
Response
\shape default
.
 This was done to avoid possibly bugs like issuing a send message request
 and expecting a list queues response.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/requestAndResponse.png
	lyxscale 15
	scale 21

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Request and Response Classes
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "requestAndResponse"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The classes that extend 
\shape italic
Request
\shape default
 are all of the format
\shape italic
 xRequest
\shape default
 where 
\shape italic
x
\shape default
 is the type of request.
 Similarly the classes that extend the 
\shape italic
Response
\shape default
 class are all of the format 
\shape italic
xResponse
\shape default
 where 
\shape italic
x
\shape default
 is the type of request related with this response.
 It might seem weird having one request and one response class for every
 possible request and response.
 But this was done to make the code extensible in case it is needed to add
 new types of requests.
 It was also done in order to simplify the implementation of the middleware.
 The implementation can be simplified because in order to create one more
 request for the system, the method has to be inserted in the 
\shape italic
MessagingProtocol
\shape default
 and then be implemented in both the 
\shape italic
ClientMessagingProtocolImpl
\shape default
 and 
\shape italic
MiddlewareMessagingProtocolImpl
\shape default
.
 Also one subclass of 
\shape italic
Request
\shape default
 and one of 
\shape italic
Response
\shape default
 have to be be implemented.
 There is no need to go around and introduce one more enum value or one
 more `else-if` statement at some part of the code
\end_layout

\begin_layout Standard
The way the described flexibility is achieved is because of the 
\shape italic
execute()
\shape default
 method.
 As can been seen the 
\shape italic
Request
\shape default
 class contains the abstract 
\shape italic
execute()
\shape default
 method that receives as a parameter a 
\shape italic
MessagingProtocol
\shape default
.
 This method is being overridden by all the subclasses of 
\shape italic
Request
\shape default
 and every one calls its correspond protocol method.
 For example the 
\shape italic
execute()
\shape default
 method in the 
\shape italic
SendMessageRequest
\shape default
 does 
\shape italic
protocol.sendMessage(...) 
\shape default
while the 
\shape italic
execute()
\shape default
 method in 
\shape italic
ListQueuesRequest
\shape default
 does 
\shape italic
protocol.listQueues()
\shape default
.
 Now when the middleware receives a request, after deserializing it it can
 just issue 
\shape italic
request.execute(...)
\shape default
 and the corresponding protocol method is going to be called.
 Therefore by taking advantage of polymorphism the middleware does not need
 a long and error-prone list of 
\begin_inset Quotes eld
\end_inset

if-else-...
\begin_inset Quotes erd
\end_inset

 statements like this: `if request is of type send message do this ...
 else if request is of list queues do this ...
 `.
 
\end_layout

\begin_layout Subsubsection*
Java 7
\end_layout

\begin_layout Standard
Initially we were planning to test our system using the Dryad cluster which
 has Java 7 installed.
 For this reason we re-implemented part of the 
\shape italic
Optional
\shape default
 class found in Java 8.
 Also almost everywhere the try-with-resources, a feature that appeared
 in Java 7, is being used so we can be assured that the respective 
\shape italic
close()
\shape default
 method is called, even in case of an exception.
\end_layout

\begin_layout Subsubsection*
Building with Ant
\end_layout

\begin_layout Standard
Ant was used to build the project.
 Ant's build file is 
\family typewriter
build.xml
\family default
 and can be found in the root directory of the project.
 It contains the following targets:
\end_layout

\begin_layout Itemize
compile: which just builds the system.
\end_layout

\begin_layout Itemize
jar: creates the executable JAR.
\end_layout

\begin_layout Itemize
test: runs all the tests of the system.
 Beware that all the tests might take some time to get executed and also
 a database needs to exist in the system for some of the tests to successfully
 get executed.
\end_layout

\begin_layout Itemize
clean: removes the generated class files and the executable JAR.
\end_layout

\begin_layout Section
Testing
\begin_inset CommandInset label
LatexCommand label
name "sec:testing"

\end_inset


\end_layout

\begin_layout Standard
Correctness of our system was of foremost importance, therefore testing
 played an impo rtant role while developing the system.
 Many parts of the system have been tested with unit tests (the Intellij
 IDEA 13 coverage tool shows that 83% of the classes were covered).
 Although testing the system took its fair amount of time we do believe
 it was worth it since it helped us find bugs while still working locally
 with the system that if they appeared when running experiments would be
 more hard to locate.
 For testing the TestNG
\begin_inset Foot
status open

\begin_layout Plain Layout
http://testng.org
\end_layout

\end_inset

 testing framework was used and also the Mockito
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/mockito/mockito
\end_layout

\end_inset

 framework was used for mocking.
 TestNG is similar to JUnit while Mockito allows the developer to easily
 and fast mock objects that would be quite expensive to construct.
 For example, the configuration files were mocked in the end-to-end tests
 using Mockito.
\end_layout

\begin_layout Standard
All the tests are located in the 
\family typewriter
src/test
\family default
 directory under the package 
\shape italic
ch.ethz.inf.asl
\shape default
.
 With the exceptions of the 
\shape italic
endtoend
\shape default
 and 
\shape italic
testutils
\shape default
 packages, all the other packages are the same as with the non-test code
 packages and under them the corresponding tests can be found.
 The tests that belong to the 
\shape italic
DATABASE
\shape default
 and 
\shape italic
END_TO_END
\shape default
 groups, defined in 
\shape italic
TestConstants
\shape default
 class in the 
\shape italic
testutils
\shape default
 package, are using the local database which is being accessed by the constants
 given in the same file.
\end_layout

\begin_layout Subsection*
Stored Functions
\end_layout

\begin_layout Standard
Since the stored functions are in some sense the core of our system, they
 have been tested thoroughly.
 
\end_layout

\begin_layout Standard
The first tests can be found in 
\shape italic
SQLFunctionsDatabaseTest
\shape default
 class and actually check that the stored functions actually do what they
 are supposed to do.
 For testing them the database is populated with some fake data taken from
 the file 
\family typewriter
src/test/resouces/populate_database.sql
\family default
 and the stored functions are applied to this populated database, after
 the stored functions are applied we verify the expected results.
\end_layout

\begin_layout Standard
The second tests can be found in 
\shape italic
SQLFunctionsConcurrentCallsDatabaseTest
\shape default
 class and they check that with the given isolation levels as explained
 in the previous section, the stored functions still operate correctly.
 This test actually creates many concurrent readers that issue receive message
 requests and at the end it is verified that no message was read more than
 once and that all messages were read.
\end_layout

\begin_layout Subsection*
End-to-End Tests
\end_layout

\begin_layout Standard
There are two end-to-end tests for our system.
 Both of them exist under the 
\shape italic
endtoend
\shape default
 package.
 The first one exists in 
\shape italic
EndToEnd
\shape default
 class while the other one in 
\shape italic
EndToEndWithMessages
\shape default
.
\end_layout

\begin_layout Subsubsection*
EndToEnd Class
\end_layout

\begin_layout Standard
This test is as close as possible to how the system is being executed and
 uses the 
\shape italic
Client
\shape default
 and 
\shape italic
Middleware
\shape default
 classes.
 It creates two middlewares and 4 clients all running on the local machine.
 In this scenario there are 2 clients connected to each middleware.
 The clients are being executed for 20 seconds and they communicate with
 each other by sending and receiving messages.
 At the end of their execution it is verified that number of requests sent
 by the clients were actually received by the middleware and no more.
 And that the number of responses sent from the middlewares were actually
 received by the clients.
 In order to check the requests and responses that were being sent and received
 we had to inject some end-to-end testing code in the normal non-testing
 code, e.g.
 method 
\shape italic
getAllRequests
\shape default
 in the 
\shape italic
Middleware
\shape default
 class.
 This was done halfheartedly since it mixes tests with the code, but at
 the end this test was useful since after every change in the system by
 running this test we could be assured that everything was still in place.
\end_layout

\begin_layout Subsubsection*
EndToEndWithMessages Class
\end_layout

\begin_layout Standard
This test uses one middleware and 2 clients that send and receive specific
 messages with each other.
 It is verified that every client actually receives the messages sent by
 the other and with the expected content.
 In order to so do it uses the 
\shape italic
ClientMessagingProtocolImpl
\shape default
 class immediately and not the 
\shape italic
Client
\shape default
 class.
\end_layout

\begin_layout Subsection*
Encountered Bugs
\end_layout

\begin_layout Standard
Here we present a view of the bugs we found by running the created tests.
\end_layout

\begin_layout Itemize
Inside a stored function we had 
\shape italic
RETURN QUERY SELECT id INTO received_message_id ...

\shape default
 and although this was not raising any problems with PostgresSQL it was
 throwing this error message when tested: 
\begin_inset Quotes eld
\end_inset

PSQLException ERROR: cannot open SELECT query as cursor
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
In the 
\shape italic
receive_message_from_sender
\shape default
 stored function we had 
\shape italic
SELECT * FROM WHERE sender_id = p_sender_id AND receiver_id = p_requesting_user_
id OR receiver_id IS NULL
\shape default
.
 Our tests were failing and we realized we were missing a parenthesis, it
 should be 
\shape italic
...
 sender_id = p_sender_id AND (receiver_id = p_requesting_user_id OR receiver_id
 IS NULL)
\shape default
 instead.
\end_layout

\begin_layout Itemize
Quite some 
\shape italic
NullPointerException
\shape default
.
 One of them was in the 
\shape italic
Message
\shape default
's
\shape italic
 equals()
\shape default
 method we had 
\shape italic
this.receiverId.equals(other.receiverId)
\shape default
 and 
\shape italic
receiverId
\shape default
 could possibly be 
\shape italic
NULL
\shape default
.
\end_layout

\begin_layout Itemize
As was said previously the idea of having the clients create themselves
 and the queues initially lead to problems because a client could have tried
 to send a message to a client that is not in the system yet.
 This was immediately noticed after implementing this functionality and
 running the end-to-end test.
\end_layout

\begin_layout Subsection*
General Encountered Problems
\end_layout

\begin_layout Standard
Unfortunately not all bugs were found by the tests.
 The most sneaky one was the following that allowed clients to receive the
 exact same message.
 This was done because the 
\shape italic
receive_message
\shape default
 stored function was like the one shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "buggyReceive"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\shape italic
SELECT id INTO received_message_id FROM message WHERE queue_id = p_queue_id
 ...;
\end_layout

\begin_layout Plain Layout

\shape italic
RETURN QUERY SELECT * FROM message WHERE queue_id = p_queue_id AND ...;
\end_layout

\begin_layout Plain Layout

\shape italic
DELETE FROM message where id = received_message_id;
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Buggy 
\shape italic
receive_message
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "buggyReceive"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The problem with the shown receive is that a message is found and selected
 but then when returning it with 
\shape italic
RETURN QUERY SELECT * FROM
\shape default
 another message could possibly be returned.
 So although the 
\shape italic
FOR UPDATE
\shape default
 explained earlier in the report was protecting us from two clients deleting
 the same message, it was not protecting us from two clients returning the
 same message.
 This bug was solved by just changing the return statement to: 
\shape italic
RETURN QUERY SELECT * FROM message WHERE id = received_message_id
\shape default
.
 The aforementioned bug was not found using tests but was noticed through
 the use of counter in the content of the messages, it was quickly noticed
 that different clients received messages with the exact same counter.
\end_layout

\begin_layout Standard
Another bug, not so important as the previous, that was also not found by
 tests but noticed while working with the system was not closing all the
 connections when closing the connection pool.
 This was because the connection pool closing method was implemented as
 shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "buggyClose"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\shape italic
for (int i = 0; i < connections.size(); ++i) { 
\end_layout

\begin_layout Plain Layout

\shape italic
InternalConnection connection; 
\end_layout

\begin_layout Plain Layout

\shape italic
try { connection = connections.take();
\end_layout

\begin_layout Plain Layout
...
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Buggy 
\shape italic
close()
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "buggyClose"

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The problem with the implementation of Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "buggyClose"

\end_inset

 was that the 
\shape italic
connection.size()
\shape default
 was returning different size in every iteration of the loop.
\end_layout

\begin_layout Section
Experimental Setup and Analysis
\begin_inset CommandInset label
LatexCommand label
name "sec:experimentalsetup"

\end_inset


\end_layout

\begin_layout Standard
In this section we present the general flow of how our experiment were conducted.
 Then, we present how we set up our instances and the implementation details
 on how we automatized the experiments.
 At the end of the section we describe how we analyzed the logs generated
 by our experiments.
\end_layout

\begin_layout Subsection*
Flow
\end_layout

\begin_layout Standard
Before presenting the exact details of our experimental setup we present
 the general flow of how an experiment is conducted, which is depicted in
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "flowExperiment"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/experimentArchitecture.png
	lyxscale 10
	scale 23

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Flow of an Experiment
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "flowExperiment"

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
EC2 Instances
\end_layout

\begin_layout Standard
All our experiments were conducted using Amazon Elastic Compute Cloud (EC2)
 instances.
 We never executed more than one middleware in one instance and never executed
 more than two executions of the 
\shape italic
Client
\shape default
 class in one instance as well.
 Also all instances of an experiment were located in the same availability
 zone
\begin_inset Foot
status open

\begin_layout Plain Layout
http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.
html
\end_layout

\end_inset

.
 We also never mixed clients, middlewares or the database in the same instance.
 
\end_layout

\begin_layout Standard
In order to setup the instances to use them for experiments we launched
 an instance based on 
\begin_inset Quotes eld
\end_inset

Ubuntu Server 14.04 LTS (HVM), SSD Volume Type
\begin_inset Quotes erd
\end_inset

 Amazon Machine Image (AMI) and for client and middleware instances we installed
 the 
\begin_inset Quotes eld
\end_inset

openjdk-7 jdk
\begin_inset Quotes erd
\end_inset

 package to be able to execute the JAR.
 For the database instance we installed 
\begin_inset Quotes eld
\end_inset

postgresql
\begin_inset Quotes erd
\end_inset

 and for both of them we installed 
\begin_inset Quotes eld
\end_inset

dstat
\begin_inset Quotes erd
\end_inset

 that was used for CPU, memory and network utilization logging.
\end_layout

\begin_layout Standard
In order for PostgreSQL to accept TCP connections and allow anybody from
 outside the instance to access our database we changed the line 
\shape italic
listen_addresses='localhost'
\shape default
 to 
\shape italic
listen_addresses='*'
\shape default
 in the 
\family typewriter
/etc/postgresql/9.3/main/postgresql.conf
\family default
 configuration file, as well as added the line 
\shape italic
host all all 0.0.0.0/0 md5
\shape default
 to the file 
\family typewriter
/etc/postgresql/9.3/main/pg_hba.conf
\family default
.
 
\end_layout

\begin_layout Standard
After those instances were created we generated their corresponding AMI's
 so we could easily launch client, middleware or database instances without
 having to re-do the installations described above.
\end_layout

\begin_layout Standard
All the instances used the same general security group that allowed access
 from any IP for all inbound and outbound connections.
 This security group was used when launching our instances.
\end_layout

\begin_layout Standard
Note that in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "flowExperiment"

\end_inset

 we show that instances are launched and terminated for every run of an
 experiment.
 This might be costly since when using EC2 instances you pay per hour even
 if you use an instance for just a minute.
 Nevertheless, this approach for doing the experiments simplified a lot
 our flow.
\end_layout

\begin_layout Standard
EC2 instances can vary in their type
\begin_inset Foot
status open

\begin_layout Plain Layout
http://aws.amazon.com/ec2/instance-types/
\end_layout

\end_inset

.
 The types
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

The t2 types of instances are designed to provide moderate baseline performance
 and the capability to burst to significantly higher performance as required
 by your workload.
\begin_inset Quotes erd
\end_inset

 (http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/t2-instances.html)
\end_layout

\end_inset

 that were used in our experiments and some of their characteristics are
 shown in the table below.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Type of Instance
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
vCPU
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Memory (GiB)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
t2.small
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
t2.medium
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
m3.large
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7.5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r3.2xlarge
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
61
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Implementation
\end_layout

\begin_layout Standard
The experimental setup implementation was solely done using Python together
 with these packages: 
\end_layout

\begin_layout Itemize
boto
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/boto/boto
\end_layout

\end_inset

 for interacting programmatically with EC2 instances.
 Its main use was to launch and terminate instances on demand.
\end_layout

\begin_layout Itemize
pexpect
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/pexpect/pexpect
\end_layout

\end_inset

 for connecting to the EC2 instances used in the experiments and executing
 appropriate commands.
 Using pexpect we connected to an EC2 instance using SSH and issued interactivel
y commands.
 For example we could start the middleware issuing a 
\begin_inset Quotes eld
\end_inset

java -jar ...
\begin_inset Quotes erd
\end_inset

 command and at some later point in time send the string 
\begin_inset Quotes eld
\end_inset

STOP
\begin_inset Quotes erd
\end_inset

 to gracefully stop the middleware.
\end_layout

\begin_layout Itemize
psycopg2
\begin_inset Foot
status open

\begin_layout Plain Layout
http://initd.org/psycopg/
\end_layout

\end_inset

 for connecting to the PostgreSQL database and getting it ready for our
 experiments.
\end_layout

\begin_layout Standard
These are the most important classes for the experiment setup residing in
 the 
\family typewriter
experiments/code
\family default
 directory.
\end_layout

\begin_layout Itemize

\shape italic
EC2Instantiator
\shape default
: contains methods to launch new instances, as well as terminate instances.
 Specifically it can create instances that can be used by clients or by
 a middleware as well as instances that are going to be used for databases.
\end_layout

\begin_layout Itemize

\shape italic
Client
\shape default
: contains methods to start clients in a client instance as well as a method
 to inform us on whether the clients have finished.
\end_layout

\begin_layout Itemize

\shape italic
Middleware
\shape default
: has methods to start the middleware in an instance as well as a method
 to gracefully stop the middleware.
\end_layout

\begin_layout Itemize

\shape italic
Database
\shape default
: contains methods that are needed to get the database in a valid initial
 state before the beginning of an experiment.
\end_layout

\begin_layout Standard
In order for the experiments to get executed, notice that the following
 have to been done in the machine running the experiments:
\end_layout

\begin_layout Itemize
The private key used to connect to the EC2 instances needs to be added in
 the 
\family typewriter
.ssh
\family default
 directory.
 This can be done issuing this command 
\shape italic
ssh-add privateKeyFile.pem
\shape default
.
 It is much easier to 
\begin_inset Quotes eld
\end_inset

ssh
\begin_inset Quotes erd
\end_inset

 a machine when the SSH key has been added, since doing 
\shape italic
ssh ubuntu@host
\shape default
 is enough to connect to the instance.
\end_layout

\begin_layout Itemize
Strict host key checking needs to be disabled
\begin_inset Foot
status open

\begin_layout Plain Layout
http://askubuntu.com/questions/87449/how-to-disable-strict-host-key-checking-in-s
sh
\end_layout

\end_inset

.
 By doing so a user does not have to manually press 
\begin_inset Quotes eld
\end_inset

Yes
\begin_inset Quotes erd
\end_inset

 when a host is unknown.
\end_layout

\begin_layout Itemize
The experiment runner assumes database's password exists in a 
\family typewriter
.pgpass
\family default
 file in the local directory that contains a line like the following: 
\shape italic
*:*:*:*:mepas$1$2$3$
\shape default
.
 By doing so you can issue a 
\begin_inset Quotes eld
\end_inset

psql
\begin_inset Quotes erd
\end_inset

 command without having to provide a password.
\end_layout

\begin_layout Standard
The experimental code can be found in 
\family typewriter
ExperimentRunner.py.

\family default
 In order to configure an experiment a Python dictionary is used in the
 
\shape italic
ExperimentRunner
\shape default
 file.
 The configuration looks similarly to the one shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "experimentConf"

\end_inset

 with added comments explaining the values that are not self-explanatory.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
conf = {
\end_layout

\begin_layout Plain Layout
"nameOfTheExperiment": "name", # corresponds to the directory where all
 logs are saved
\end_layout

\begin_layout Plain Layout
"username": "ubuntu", # username for the EC2 instances
\end_layout

\begin_layout Plain Layout
"placement": "us-west-2c", # availability zone to be used by all instances
\end_layout

\begin_layout Plain Layout
"databaseType": "m3.large", 
\end_layout

\begin_layout Plain Layout
"clientInstances": (2, "m3.large"), # number of client instances and their
 type 
\end_layout

\begin_layout Plain Layout
"middlewareInstances": (2, "m3.large"), # number of middleware instances
 and their type
\end_layout

\begin_layout Plain Layout
"databaseUsername": "ubuntu", 
\end_layout

\begin_layout Plain Layout
"databasePassword": "mepas$1$2$3$", 
\end_layout

\begin_layout Plain Layout
"databaseName": "mepas", 
\end_layout

\begin_layout Plain Layout
"databasePortNumber": 5432, 
\end_layout

\begin_layout Plain Layout
"middlewarePortNumber": 6789, 
\end_layout

\begin_layout Plain Layout
"runningTimeInSeconds": 600, 
\end_layout

\begin_layout Plain Layout
"threadPoolSize": 20, 
\end_layout

\begin_layout Plain Layout
"connectionPoolSize": 20, 
\end_layout

\begin_layout Plain Layout
"totalClients": 100, 
\end_layout

\begin_layout Plain Layout
"totalQueues": 50, 
\end_layout

\begin_layout Plain Layout
"messageSize": 20, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
# 
\begin_inset Quotes eld
\end_inset

mappings
\begin_inset Quotes erd
\end_inset

 maps a client instance to a middleware instance in the form 
\shape italic
(a, b)
\end_layout

\begin_layout Plain Layout
# where 
\shape italic
a
\shape default
 corresponds to the index of a client instance and 
\shape italic
b
\shape default
 to the index of
\end_layout

\begin_layout Plain Layout
# a middleware instance.
 Indexes start from 0.
 For instance in the following mapping
\end_layout

\begin_layout Plain Layout
the first tuple states that we connect the first client instance with the
 first middleware.
\end_layout

\begin_layout Plain Layout
"mappings": [(0, 0), (1, 1)], 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
# 
\begin_inset Quotes eld
\end_inset

clientsData
\begin_inset Quotes erd
\end_inset

 contains pairs in order of the form 
\shape italic
(a, b)
\shape default
 where 
\shape italic
a
\shape default
 corresponds to the 
\end_layout

\begin_layout Plain Layout
# numberOfClients per instance and 
\shape italic
b
\shape default
 the startingId of every client.
 The first tuple 
\end_layout

\begin_layout Plain Layout
# of 
\begin_inset Quotes eld
\end_inset

clientsData
\begin_inset Quotes erd
\end_inset

 corresponds to the first client instance, second to the second, etc.
 
\end_layout

\begin_layout Plain Layout
"clientsData": [(50, 1), (50, 51)], 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
"variable": "threadPoolSize", # value that is going to be changed for the
 experiments
\end_layout

\begin_layout Plain Layout
"values": [5, 10, 15] # possible values in this case correspond to thread
 pool sizes
\end_layout

\begin_layout Plain Layout
}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Experiment Configuration
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "experimentConf"

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The configuration shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "experimentConf"

\end_inset

 cannot be used for all kind of experiments.
 For example it cannot be used in an experiment trying to increase two values
 at the same time.
 In such cases a small addition was done inside the 
\shape italic
for
\shape default
 loop of our experiments, the 
\shape italic
for
\shape default
 loop actually corresponds to the loop shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "flowExperiment"

\end_inset

.
 For instance if we needed to run an experiment increasing both the number
 of threads and the number of connections we could just use the given configurat
ion and also add the statement 
\shape italic
conf[
\begin_inset Quotes eld
\end_inset

connectionPoolSize
\begin_inset Quotes erd
\end_inset

]=variable
\shape default
 in our 
\shape italic
for
\shape default
 loop.
 The 
\shape italic
for
\shape default
 loop was also added in a function so we can use multithreading to run experimen
ts concurrently.
 Note however that all the experiments running at the same time cannot use
 more than 20 
\series bold
running
\series default
 instances since this is the limit given by Amazon on a specific availability
 zone.
\end_layout

\begin_layout Subsection*
Analysis
\end_layout

\begin_layout Standard
The code that analyses the generated logs from the experiments can be found
 in the 
\family typewriter
ResultReader.py
\family default
 file in the 
\family typewriter
experiments/code
\family default
 directory.
 It contains the following methods:
\end_layout

\begin_layout Itemize

\shape italic
getTrace()
\shape default
: since the trace is a different kind of an experiment with respect to the
 others it also has its own function for analyzing it.
 This function was used to break the trace in intervals of one minute and
 calculating throughput and response time.
\end_layout

\begin_layout Itemize

\shape italic
getThroughput()
\shape default
: this function is used to calculate the throughput of an experiment.
\end_layout

\begin_layout Itemize

\shape italic
getResponseTime()
\shape default
: this function is used to calculate the response time of an experiment.
\end_layout

\begin_layout Itemize

\shape italic
getTimeSpentOnEachComponent()
\shape default
: this function uses the middleware logs to find the average time spent
 on each component of the middleware, e.g.
 waiting to be picked up by a worker thread, waiting to get a connection
 etc.
\end_layout

\begin_layout Itemize

\shape italic
getCPUUsage()
\shape default
: used to calculate the average CPU utilization of an experiment given the
 corresponding CPU usage file generated by dstat.
\end_layout

\begin_layout Standard
All the aforementioned functions use extensively UNIX commands like awk,
 sed, grep, cat, wc and others.
 This was done to achieve faster analysis of the logs.
 For example for calculating the number of lines of a file a 
\begin_inset Quotes eld
\end_inset

wc
\begin_inset Quotes erd
\end_inset

 command is called from within Python instead of opening and reading every
 single line of the file.
 Another example would be removing the warm-up and cool-down phase of an
 experiment which can be simply done like this: 
\shape italic
awk -F'
\backslash
t' '$1 >= warmUpInSeconds && $1 <= (lastTimeInSeconds - coolDownInSeconds)
 { print; }' file
\shape default
.
\end_layout

\begin_layout Subsubsection*
Plots
\end_layout

\begin_layout Standard
For plotting the results of our experiments we used Gnuplot
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.gnuplot.info/
\end_layout

\end_inset

.
 The plotting code can be found in the files with the 
\begin_inset Quotes eld
\end_inset

.gnu
\begin_inset Quotes erd
\end_inset

 extension under every experiment in the 
\family typewriter
report
\family default
 directory.
\end_layout

\begin_layout Section
Experiments
\begin_inset CommandInset label
LatexCommand label
name "sec:experiments"

\end_inset


\end_layout

\begin_layout Standard
In this section we present the experiments conducted including their evaluation.
 In all the experiments client's throughput and response time was presented
 unless stated otherwise.
 Also, all the receives of messages in our experiments were successful.
\end_layout

\begin_layout Subsection*
Stability
\end_layout

\begin_layout Standard
In order to check our system's stability we ran an one hour trace with the
 following configuration:
\end_layout

\begin_layout Itemize
2 t2.small client instances with 50 clients each
\end_layout

\begin_layout Itemize
1 t2.small middleware instance with 20 middleware threads and 20 connections
\end_layout

\begin_layout Itemize
1 t2.medium database
\end_layout

\begin_layout Standard
Note that this configuration uses instances of type T2.
 Those are problematic instances for running experiments since they have
 burstable performance.
 T2 instances receive CPU credits every hour which can then be used to give
 more processing resources to the instances.
 Before having the experimental setup we explained in the previous section
 we a had a slightly different one.
 We were not terminating instances after every experiment but were reusing
 them instead.
 The trace was executed in instances that were running for quite some time
 without being used and therefore their burst-ability did not interfere
 with our trace.
\end_layout

\begin_layout Standard
In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "trace"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "trace-1"

\end_inset

 the throughput and response time values of our traces can been seen.
 In the response time figure, response time was averaged over the interval
 of one minute while in the throughput figure throughput was calculated
 per second and averaged over the interval of one minute.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename trace1Hour/throughput/throughput.eps
	scale 120

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Throughput of an one hour trace with 2 client instances (50 clients/instance)
 and 1 middleware instance (20 threads, 20 connections)
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "trace"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename trace1Hour/responseTime/responseTime.eps
	scale 120

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Response time of an one hour trace with 2 client instances (50 clients/instance)
 and 1 middleware instance (20 threads, 20 connections)
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "trace-1"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Based on the results of the trace, we calculated the average of all types
 of requests which is 16.668 milliseconds, as well as the time spent on a
 specific request shown below:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Type of Request
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Average Response Time (ms)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Standard Deviation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RECEIVE_MESSAGE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17.10725
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.51819 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SEND_MESSAGE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17.1355
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.543025
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LIST_QUEUES
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15.7621
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.689385
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\end_layout

\begin_layout Standard
We were also interested in the time spent on each component during the trace,
 those values are presented below:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Time spent on ...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Average Response Time (ms)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Standard Deviation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
waiting for a MW thread
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13.3207
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.17608
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
waiting to get a DB connection
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.000689706
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.216034
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
executing a DB request
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.23399
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.38918
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
working inside the MW thread
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.33539
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.51786
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The time to receive a connection is almost nonexistent, this is because
 the amount of worker threads is the same with the number of connections,
 so when a worker thread asks for a connection one can be immediately given
 back to the thread.
 The time waiting for a worker thread is quite high and was to be expected
 since we have 100 clients and only 20 worker threads.
 So at any point in time 80 clients connections could possibly be waiting.
\end_layout

\begin_layout Standard
As we can see our system is stable under load.
 In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "trace"

\end_inset

 we see that the throughput for the RECEIVE_MESSAGE, SEND_MESSAGE and LIST_QUEUE
S requests is pretty much the same.
 This is because every client issues the exact amount of SEND_MESSAGE and
 LIST_QUEUES requests and because a RECEIVE_MESSAGE is only called if a
 message is going to be received.
 So the amount of SEND_MESSAGE requests should be almost the same with the
 amount of RECEIVE_MESSAGE requests.
 Because of this, in the upcoming experiments we are not going to plot the
 throughput for a specific type of a request but only for all types of requests.
\end_layout

\begin_layout Standard
The average response time of the LIST_QUEUES is a bit lower than the response
 time of the two other types of requests.
 Our assumption was that this is because LIST_QUEUES does not modify the
 database, neither with an INSERT or a DELETE.
 To verify this claim we checked the database request average response time
 for every type of request.
 The results verified our claim and are shown below:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Type of Request
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Average Database Response Time (ms)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RECEIVE_MESSAGE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.60231
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SEND_MESSAGE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.71801
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LIST_QUEUES
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.38218
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally we note that in our trace 99.7% of the requests were served in less
 than 50ms, 97% in under 25ms and 86% under 20ms.
\end_layout

\begin_layout Standard
As was mentioned earlier in this report, we have a 
\series bold
closed system
\series default
.
 This means that the interactive response time law should apply to our results.
 The interactive law states that 
\begin_inset Formula $R=\frac{N}{X}-Z$
\end_inset

 where 
\begin_inset Formula $R$
\end_inset

 is the response time, 
\begin_inset Formula $N$
\end_inset

 is the number of clients issuing requests, 
\begin_inset Formula $Z$
\end_inset

 is the think time and 
\begin_inset Formula $X$
\end_inset

 is the throughput.
 Our average response time is 16.668ms, we have 100 clients and our think
 time is 0.
 In reality 
\begin_inset Formula $Z$
\end_inset

 is a positive value since we have to serialize and deserialize objects
 but this time is considered negligible.
 This means that throughput should be 
\begin_inset Formula $X=\frac{N}{R+Z}=\frac{100}{16.668+0}=5.999$
\end_inset

.
 The value 
\begin_inset Formula $5.999$
\end_inset

 corresponds to the number of requests per millisecond.
 Per second it is 
\begin_inset Formula $5999$
\end_inset

 which is close to the average throughput (of all the trace) that is 
\begin_inset Formula $5897$
\end_inset

 requests per second.
 All the upcoming results have been verified using the interactive law.
\end_layout

\begin_layout Section*
Warm Up and Cool Down
\end_layout

\begin_layout Standard
For all the following experiments, every data point in the plots corresponds
 to a 10 minute execution.
 From those 10 minutes the first 2 minutes have been removed, as well as
 the last 1 minute.
 Those minutes have been removed as they are considered the 
\begin_inset Quotes eld
\end_inset

warm up
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

cool down
\begin_inset Quotes erd
\end_inset

 phases respectively.
 Those number were derived by checking the trace and seeing that after 2
 minutes our system stabilizes and until one minute before the end of the
 execution the system is still stable.
\end_layout

\begin_layout Subsection*
Throughput Plots
\end_layout

\begin_layout Standard
In all the following plots the throughput was calculated per 20 seconds
 and averaged over the time of the experiment (excluding 
\begin_inset Quotes eld
\end_inset

warm up
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

cool down
\begin_inset Quotes erd
\end_inset

 phases of course).
\end_layout

\begin_layout Subsection*
Increasing the Message Size
\end_layout

\begin_layout Standard
In this experiment we increased the size of the messages that are sent between
 the clients.
 While running those experiments we realized clients were receiving the
 following failed response:
\end_layout

\begin_layout Standard
\align center
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 1
use_makebox 0
width "90col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
ch.ethz.inf.asl.exceptions.MessagingProtocolException:
\end_layout

\begin_layout Plain Layout
failed to send message ERROR: could not extend file "base/16389/16427.6":
 No space left on device Hint: Check free disk space.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We realized the problem was the amount of available memory in our instance's
 disk.
 We solved this problem by increasing the available size of our disks and
 reran the experiments.
 Afterwards no such failed response was received.
 The disk space was increasing because we are not VACUUMing
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.postgresql.org/docs/9.3/static/sql-vacuum.html
\end_layout

\end_inset

 our database and it is known that tuples that are deleted are not physically
 removed from their tables until a VACUUM is issued.
\end_layout

\begin_layout Standard
The experiment was concuded with the following configuration:
\end_layout

\begin_layout Itemize
1 m3.large client instance with 50 clients 
\end_layout

\begin_layout Itemize
1 m3.large middleware with 20 middleware threads and 20 connections
\end_layout

\begin_layout Itemize
1 m3.large database
\end_layout

\begin_layout Itemize
message sizes in number of characters, values that were used are: 
\begin_inset Formula $1$
\end_inset

, 
\begin_inset Formula $500$
\end_inset

, 
\begin_inset Formula $1000$
\end_inset

, 
\begin_inset Formula $5000$
\end_inset

, 
\begin_inset Formula $10^{4}$
\end_inset

, 
\begin_inset Formula $2\cdot10^{4}$
\end_inset

, 
\begin_inset Formula $3\cdot10^{4}$
\end_inset

, 
\begin_inset Formula $4\cdot10^{4}$
\end_inset

, 
\begin_inset Formula $5\cdot10^{4}$
\end_inset

, 
\begin_inset Formula $10^{5}$
\end_inset

, 
\begin_inset Formula $15\cdot10^{4}$
\end_inset

, 
\begin_inset Formula $2\cdot10^{5}$
\end_inset

, 
\begin_inset Formula $5\cdot10^{5}$
\end_inset

 and 
\begin_inset Formula $10^{6}$
\end_inset


\end_layout

\begin_layout Standard

\series bold
Hypothesis
\series default
: We expect to have increased response times as well as decreased throughput.
 This is because by increasing the message size network time needed to send
 and receive a message will increase but most importantly because the database
 is going to become slower when handling more data.
 We say the database and not the network because by using the iperf
\begin_inset Foot
status open

\begin_layout Plain Layout
https://iperf.fr/
\end_layout

\end_inset

 tool we saw bandwidth between instances of the magnitude of some Gbps (1Gbps+).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename increasingMessageSize/throughput/throughput.eps
	scale 120

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Throughput when Increasing the Message Size
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "increasingMessageSize"

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename increasingMessageSize/responseTime/responseTime.eps
	scale 120

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Response Time when Increasing the Message Size
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "increasingMessageSize-1"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As we can see in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "increasingMessageSize"

\end_inset

 and Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "increasingMessageSize-1"

\end_inset

 there is a huge increase in the response time as well as a huge decrease
 in the throughput as was expected.
 We also see that LIST_QUEUES requests have less response time than both
 
\begin_inset Quotes eld
\end_inset

SEND_MESSAGE
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

RECEIVE_MESSAGE
\begin_inset Quotes erd
\end_inset

.
 This was expected but we weren't expecting such a huge response time for
 LIST_QUEUES requests since they do not move any messages around.
 While investigating why this was the case we found the following message
 in the PostgreSQL logs: 
\begin_inset Quotes eld
\end_inset

HINT: Consider increasing the configuration parameter "checkpoint_segments".
 2014-11-05 21:29:32 UTC LOG: checkpoints are occurring too frequently (2
 seconds apart)
\begin_inset Quotes erd
\end_inset

.
 A checkpoint is: 
\begin_inset Quotes eld
\end_inset

a point in the transaction log sequence at which all data files have been
 updated to reflect the information in the log.
 All data files will be flushed to disk.
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.postgresql.org/docs/9.3/static/sql-checkpoint.html
\end_layout

\end_inset

.
 So this could explain why LIST_QUEUES had such a huge response time.
 Also the checkpoints can explain why RECEIVE_MESSAGE requests have such
 a greater response time than SEND_MESSAGE requests since a RECEIVE_MESSAGE
 request never 
\begin_inset Quotes eld
\end_inset

puts
\begin_inset Quotes erd
\end_inset

 something in the database, it is not this request that fires up the checkpoint
 but it is a SEND_MESSAGE instead.
 To verify our claims we did one more experiment.
 In order to prove this claim we run once more the experiment with 
\begin_inset Formula $10^{6}$
\end_inset

 characters per message but this time we changed the configuration of our
 database concerning its checkpoints.
 So we changed the file 
\family typewriter
/etc/postgresql/9.3/main/postgresql.conf
\family default
 to contain the following:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 1
use_makebox 0
width "90col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
# - Checkpoints -
\end_layout

\begin_layout Plain Layout
checkpoint_segments = 
\series bold
64
\series default
 # in logfile segments, min 1, 16MB each 
\end_layout

\begin_layout Plain Layout
checkpoint_timeout = 12min # range 30s-1h 
\end_layout

\begin_layout Plain Layout
checkpoint_completion_target = 0.5 # checkpoint target duration, 0.0 - 1.0
 
\end_layout

\begin_layout Plain Layout
checkpoint_warning = 30s # 0 disables
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With this configuration we did not receive any HINT's in our databases'
 log file and the response times were the following:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Type of Request
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Average Response Time (ms)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Standard Deviation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RECEIVE_MESSAGE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
393.903
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
769.763 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SEND_MESSAGE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1518.57
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1894.07
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LIST_QUEUES
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
186.319
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
568.049
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
All types of requests
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
699.703
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1357.94
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\end_layout

\begin_layout Standard
while with the previous configuration we had those results: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Type of Request
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Average Response Time (ms)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Standard Deviation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RECEIVE_MESSAGE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
901.7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
420.242 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SEND_MESSAGE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2032.84
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
527.611
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LIST_QUEUES
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
507.133
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
382.042
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
All types of requests
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1146.8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
786.268
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\end_layout

\begin_layout Standard
More 
\begin_inset Quotes eld
\end_inset

checkpoint_segments
\begin_inset Quotes erd
\end_inset

 implies less often logging a checkpoint so we have better performance.
 The above tables proves our claim since now LIST_QUEUES and RECEIVE_MESSAGE
 are quite faster and much less compared to SEND_MESSAGE requests which
 is the one creating the logs of the checkpoints.
 The high standard deviation in all of those experiments is easily explained
 by realizing that when no log checkpoint is taking place, database requests
 can be served quite quickly but at the moments when checkpoints are being
 logged the system as a whole becomes slower and therefore we have higher
 database requests response times.
\end_layout

\begin_layout Subsection*
Number of Connections Versus Number of Middleware Threads
\end_layout

\begin_layout Standard
In our system design there is strong correspondence between database connections
 and middleware threads given to the database.
 We wanted to have a better look at the performance of the system when those
 two factors are combined.
\end_layout

\begin_layout Subsubsection*
Increasing the Number of Connections
\end_layout

\begin_layout Standard
In this experiment we increased the number of connections to the database
 while everything else remained stable.
 This experiment was conducted with the following confugration:
\end_layout

\begin_layout Itemize
1 m3.large client instance with 50 clients 
\end_layout

\begin_layout Itemize
1 m3.large middleware with 20 middleware threads
\end_layout

\begin_layout Itemize
1 m3.large database
\end_layout

\begin_layout Standard

\series bold
Hypothesis
\series default
: Since we have 50 clients and 20 middleware threads we would expect that
 by increasing the number of connections the throughput is going to increase
 and response time is going to decrease.
 This is excepted to happen until the number of connection reaches 20.
 Afterwards we except that the introduction of more connections is not really
 going to 
\begin_inset Quotes eld
\end_inset

help
\begin_inset Quotes erd
\end_inset

 the system since it only has 20 middleware threads and throughput is going
 to get saturated.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename increasingConnections/throughput/throughput.eps
	scale 120

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Throughput when Increasing the Number of Connections
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "increasingNumberOfConnections"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename increasingConnections/responseTime/responseTime.eps
	scale 120

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Response Time when Increasing the Number of Connections
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "increasingNumberOfConnections-1"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "increasingNumberOfConnections"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "increasingNumberOfConnections-1"

\end_inset

 show the throughput and response time of our system while increasing the
 number of connections.
 The corresponding results were as expected up to 20 number of connections.
 After 20 connections we see a slow decrease in throughput which was not
 excepted.
 But still the reduced throughput can be explained by the way our connection
 pool is used.
 A call to 
\shape italic
getConnection()
\shape default
 from our connection pool is always going to return a new connection if
 the number of maximum connections has not been reached yet and only then
 it is going to start reusing connections.
 So in our case when we have for instance 80 connections there are going
 to be created 80 connections in the pool although only 20 of them are being
 used at a specific point in time.
 This means that the database is going to be overwhelmed with more new processes
: 
\begin_inset Quotes eld
\end_inset

As we do not know ahead of time how many connections will be made, we have
 to use a master process that spawns a new server process every time a connectio
n is requested.
 
\begin_inset Quotes eld
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.postgresql.org/docs/9.3/static/connect-estab.html
\end_layout

\end_inset

 Making the database slower has as a consequence of slowing up our system
 and therefore reduced throughput.
\end_layout

\begin_layout Subsubsection*
Increasing the Number of Threads
\end_layout

\begin_layout Standard
In this experiment we increased the number of middleware threads while everythin
g else remained the same.
 For this experiment we had the following configuration:
\end_layout

\begin_layout Itemize
1 m3.large client instance with 50 clients 
\end_layout

\begin_layout Itemize
1 m3.large middleware with 20 connections
\end_layout

\begin_layout Itemize
1 m3.large database
\end_layout

\begin_layout Standard

\series bold
Hypothesis
\series default
: Because we have 20 connections in our system we would except throughput
 to increase as we increase the number of threads, since with more threads
 we will be able to utilize the given connections.
 We except throughput to get saturated after about 20 threads since the
 middleware threads will not be able to receive connections.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename increasingThreads/throughput/throughput.eps
	scale 112

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Throughput when Increasing the Number of Threads
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "increasingNumberOfThreads"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename increasingThreads/responseTime/responseTime.eps
	scale 112

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Response Time when Increasing the Number of Threads
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "increasingNumberOfThreads-1"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As we can see in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "increasingNumberOfThreads"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "increasingNumberOfThreads-1"

\end_inset

 the throughput increased as excepted and gets saturated after 20 threads,
 though there still are some glitches.
 We also see high variance in the response time after 50 threads.
 Both of these observations can be explained.
 The reason is that our system has 50 clients, so when we have 50 threads
 we can think there is a correspondence between threads and clients.
 After 50 clients there is contention between the threads on which is going
 to pick up the client, i.e.
 which thread is going to pick up a socket.
\end_layout

\begin_layout Subsubsection*
Increasing Both Threads and Connections
\end_layout

\begin_layout Standard
With this experiment we wanted to see what will happen when increasing the
 number of middleware threads and connections at the same time.
 For this experiment we had the following configuration:
\end_layout

\begin_layout Itemize
1 m3.large client instance with 50 clients 
\end_layout

\begin_layout Itemize
1 m3.large middleware
\end_layout

\begin_layout Itemize
1 m3.large database
\end_layout

\begin_layout Standard

\series bold
Hypothesis
\series default
: blah
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename increasingBothClientsAndConnections/throughput/throughput.eps
	scale 110

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename increasingBothClientsAndConnections/responseTime/responseTime.eps
	scale 120

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Increasing Both the Number of Threads and Connections
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "increasingBoth"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As we can see in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "increasingBoth"

\end_inset

 blha.
\end_layout

\begin_layout Subsection*
Number of Clients in one Middleware
\end_layout

\begin_layout Standard
For this experiment we wanted to see what will happen if we increase the
 number of clients in our system.
 
\end_layout

\begin_layout Subsubsection*
Increasing Number of Clients
\end_layout

\begin_layout Standard
In this experiment we increased the number of clients with the following
 configuration:
\end_layout

\begin_layout Itemize
1 m3.large client instance with a variable number clients 
\end_layout

\begin_layout Itemize
1 m3.large middleware with 20 middleware threads and 20 connections
\end_layout

\begin_layout Itemize
1 m3.large database
\end_layout

\begin_layout Standard

\series bold
Hypothesis
\series default
: Increasing the number of clients is expected to have a consequence on
 the throughput which is going to increase.
 By checking previous experiments on what was the CPU utilization of the
 instances running the clients we would assume that you can run quite some
 clients before having contention problems in your client's instance.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename increasingClientsOneInstance/throughput/throughput.eps
	scale 120

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename increasingClientsOneInstance/responseTime/responseTime.eps
	scale 120

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Increasing the Number of Clients
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "increasingClients"

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Looking at Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "increasingClients"

\end_inset

 we can see that throughput increases and saturates at about 100 clients.
 On the other hand response time is strictly increasing.
 We believe that the increase in response time and the early saturation
 has nothing to do with the instances running the clients.
 To prove our claim we conducted the next experiment where we spread the
 clients in many instances.
\end_layout

\begin_layout Subsubsection*
Spreading Clients
\end_layout

\begin_layout Standard
In order to prove that in our previous experiment there was no contention
 in the clients and that clients are not the bottlenech of oyr system we
 conducted the following experiment where we took 100 clients and spreaded
 them across multiple client instances.
 Initially we started with one client instance having 100 clients, then
 2 client instances having 50 clients each, etc.
 The configuration for this experiment was the following:
\end_layout

\begin_layout Itemize
Variable number of m3.large client instances, values checked were 1, 2, 4,
 5 and 10
\end_layout

\begin_layout Itemize
1 m3.large middleware with 20 middleware threads and 20 connections
\end_layout

\begin_layout Itemize
1 m3.large database
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename spreadingClients/throughput/throughput.eps
	scale 110

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename spreadingClients/responseTime/responseTime.eps
	scale 110

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Spreading Clients into Many Client Instances
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "spreadingClients"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can see in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "spreadingClients"

\end_inset

 that even when we spread the 100 clients in many instances throughput is
 not changed.
 If the reason throughput saturated in 100 clients was because of contention
 on the clients instance then spreading the clients in many instances would
 have improved throughput which is not the case.
 This leads us to state the bottleneck of our system is for sure not the
 clients.
\end_layout

\begin_layout Subsection*
Speedup - Finding the Bottleneck
\end_layout

\begin_layout Standard
It is our belief that the bottleneck of our system is the database.
 In order to prove our claim we are going to check what happens when increasing
 the number of middlewares while the workload remains constant.
 For this experiment we decided to use a r3.2xlarge instance for the database
 to show that even with such a powerful machine the database is going to
 utilize most of its CPU usage while increasing the number of middlewares.
 The configuration of this experiment was the following:
\end_layout

\begin_layout Itemize
10 m3.large client instances with 100 clients each 
\end_layout

\begin_layout Itemize
Variable number of middlewares with 20 middleware threads and 20 connections
 each.
 Number of middlewares that was used was 1, 2 and 5.
 We could not try with 10 middlewares since such an experiment would need
 21 instances to get executed.
 Then amount of clients was also uniformly distributed to the middlewares,
 e.g.
 with 2 middlewares 5 client instances were connected to the one middleware
 and the other 5 instances to the other middleware.
\end_layout

\begin_layout Itemize
1 r3.2xlarge database instance
\end_layout

\begin_layout Standard
In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "speedup"

\end_inset

we can see the speedup.
 Speedup corresponds to the response time using 1 middleware divided by
 the response time using N middlewares.
 The speedup was calculated based on the following data where average response
 time corresponds to the average response time of all the requests:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of Middlewares
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Average Response Time (ms)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Standard Deviation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
98.3874
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
26.3294
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
59.6998
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20.969
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
57.0587
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
21.3355
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The goal was to show that response time is not proportionally decreased
 when increasing the middlewares since the database is the bottleneck.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename speedup/speedup/throughput.eps
	scale 110

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Speedup
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "speedup"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As we can see in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "speedup"

\end_inset

 when increasing the number of middlewares from one to two there is significant
 increase of about 64% since the new speedup is 1.64.
 But increasing the middlewares from two to 5 has a negligible speedup.
 This is because the database is not able to support the increased number
 of requests received from the five middlewares.
 In order to prove our claim we generated a plot depicted in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "CPUUtilization"

\end_inset

 corresponding to CPU utilization of the middlewares and the database while
 the number of middlewares is increased.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename speedup/cpuUtilization/utilization.eps
	scale 110

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
CPU Utilization of Database and Middleware Instances
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "CPUUtilization"

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
As we can see in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "CPUUtilization"

\end_inset

 the average middleware CPU utilization is reduced when we increase the
 number of middlewares while the database CPU utilization increases.
 Please note that this graph might be a bit misleading since a database
 is executed on an r3.2xlarge instance with 8 virtual CPUs while a middleware
 runs on an m3.large instance with 2 virtual CPUs.
 So the difference between CPU utilization in terms of resouces is much
 higher than the one depicted in the figure.
 
\end_layout

\begin_layout Standard
It is our belief that the aforementioned experiments show that the database
 is the bottleneck.
\end_layout

\begin_layout Subsection*
Scale-Up and Scale-Out
\end_layout

\begin_layout Standard
Finally we present the scale-up and scale-out functions of our system shown
 in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "scaleUp"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "scaleOut"

\end_inset

 respectively.
 Scale-out tests how our system deals when increasing both the clients and
 the middlewares and is defined as the response time having one client instance
 and one middleware divided by the response time when having N client instances
 using N middlewares.
 Similarly to scale-up, scale-out tests how our system behaves with increasing
 load but instead of response-time it is based on the throughput.
 Both scale-up and scale-out should ideally be constant.
 For the scaling experiments we used the following configuration:
\end_layout

\begin_layout Itemize
Variable number of m3.large client instances with 100 clients each 
\end_layout

\begin_layout Itemize
Variable number of middlewares with 20 middleware threads and 20 connections
 each
\end_layout

\begin_layout Itemize
One r3.2xlarge database instance
\end_layout

\begin_layout Standard
For this experiment we increased the number of maximum connections in the
 PostgreSQL configuration file to 200 changing the 
\shape italic
max_connections
\shape default
 line in the 
\family typewriter
/etc/postgresql/9.3/main/postgresql.conf
\family default
 file.
 This was done because when we use 9 middlewares the databasse needs to
 open 9 times 20 connections which exceeded PostgreSQL default maximum connectio
n size.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename scaleout/scaleup/scaleup.eps
	scale 110

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Scale-Up
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "scaleUp"

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename scaleout/scaleout/throughput.eps
	scale 110

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Scale-Out
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "scaleOut"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As we can see in Figures 
\begin_inset CommandInset ref
LatexCommand ref
reference "scaleUp"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "scaleOut"

\end_inset

 both scale-up and scale-out are far from the ideal one which was excepted
 since the database prevents them from being closer to the ideal one.
\end_layout

\begin_layout Subsection*
Encountered Problems
\end_layout

\begin_layout Standard
During some initial experimenting with the system we had the following problem,
 that seem quite naive in retrospective.
 We were changing only the database instance type to a better one, from
 m3.large to m3.2xlarge and the system's throughput was decreased! It came
 to our realization that the new launched database was running in the 
\begin_inset Quotes eld
\end_inset

us-west-2a
\begin_inset Quotes erd
\end_inset

 zone instead of the 
\begin_inset Quotes eld
\end_inset

us-west-2c
\begin_inset Quotes erd
\end_inset

 were the clients and the middleware were running.
 We were not aware that this was possible since we did not know about availabili
ty zones inside a region.
 This was fixed afterwards and all our experiments were executed in the
 same availability zone.
\end_layout

\begin_layout Section
Conclusion
\begin_inset CommandInset label
LatexCommand label
name "sec:conclusion"

\end_inset


\end_layout

\begin_layout Standard
At the end if we could design the system anew we would not change many aspects
 of its design.
 But we would change a bit the experimental setup so it is easier to run
 more experiments and get back graphs instead of manually calling the 
\shape italic
getResponse()
\shape default
 or 
\shape italic
getThroughput()
\shape default
 methods and passing them to Gnuplot.
 We would also have followed a more iterative approach: changing something
 in the system, running the experiments, getting back the experimental results,
 changing something in the system, ...
 .
\end_layout

\begin_layout Standard
We believe we developed a nice system and had a good understanding of our
 system where we showed that the database is its bottleneck.
 We are also confident that we learned a lot about developing and benchmarking
 applications, some database internal characteristics, as well as deploying
 an application to the cloud.
\end_layout

\end_body
\end_document
